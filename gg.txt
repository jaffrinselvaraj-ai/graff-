import heapq
import math
import time
import random

# --- Graph Data Structure ---
class Graph:
    def __init__(self):
        self.edges = {}

    def add_edge(self, from_node, to_node, weight):
        if from_node not in self.edges:
            self.edges[from_node] = []
        self.edges[from_node].append((to_node, weight))

    def get_neighbors(self, node):
        return self.edges.get(node, [])

# --- Heuristic Functions ---
def h1(node, goal):
    """Manhattan distance heuristic"""
    return abs(node[0] - goal[0]) + abs(node[1] - goal[1])

def h2(node, goal):
    """Euclidean distance heuristic"""
    return math.sqrt((node[0] - goal[0])**2 + (node[1] - goal[1])**2)

def h3(node, goal):
    """Custom heuristic (e.g., synthetic road network, could be adjusted)"""
    return max(abs(node[0] - goal[0]), abs(node[1] - goal[1]))

# --- A* Algorithm ---
def a_star(graph, start, goal, heuristic):
    open_list = []
    heapq.heappush(open_list, (0 + heuristic(start, goal), start))  # (f_score, node)
    g_scores = {start: 0}
    came_from = {}

    while open_list:
        _, current_node = heapq.heappop(open_list)

        if current_node == goal:
            path = []
            while current_node in came_from:
                path.append(current_node)
                current_node = came_from[current_node]
            path.append(start)
            path.reverse()
            return path

        for neighbor, weight in graph.get_neighbors(current_node):
            tentative_g_score = g_scores[current_node] + weight
            if neighbor not in g_scores or tentative_g_score < g_scores[neighbor]:
                g_scores[neighbor] = tentative_g_score
                f_score = tentative_g_score + heuristic(neighbor, goal)
                heapq.heappush(open_list, (f_score, neighbor))
                came_from[neighbor] = current_node

    return None  # No path found

# --- Random Graph Generation (For Testing) ---
def generate_random_graph(num_nodes, max_edges_per_node, max_weight):
    graph = Graph()
    nodes = [(i, j) for i in range(num_nodes) for j in range(num_nodes)]  # Grid nodes as an example
    for node in nodes:
        num_edges = random.randint(1, max_edges_per_node)
        for _ in range(num_edges):
            neighbor = random.choice(nodes)
            weight = random.randint(1, max_weight)
            if node != neighbor:
                graph.add_edge(node, neighbor, weight)
    return graph

# --- Benchmarking with Time ---
def run_benchmark(graph, start, goal):
    # Measure time for A* with different heuristics
    print(f"Starting benchmark for start: {start}, goal: {goal}")
    
    # Heuristic 1: Manhattan distance
    start_time = time.time()
    path_h1 = a_star(graph, start, goal, h1)
    end_time = time.time()
    print(f"Time with h1 (Manhattan distance): {end_time - start_time} seconds")
    
    # Heuristic 2: Euclidean distance
    start_time = time.time()
    path_h2 = a_star(graph, start, goal, h2)
    end_time = time.time()
    print(f"Time with h2 (Euclidean distance): {end_time - start_time} seconds")
    
    # Heuristic 3: Custom heuristic
    start_time = time.time()
    path_h3 = a_star(graph, start, goal, h3)
    end_time = time.time()
    print(f"Time with h3 (Custom heuristic): {end_time - start_time} seconds")
    
    # Return the best performing path (based on time)
    return path_h1, path_h2, path_h3

# --- Main Execution ---
if __name__ == "__main__":
    # Generate a random graph with 50 nodes, max 5 edges per node, and max weight of 10
    random_graph = generate_random_graph(50, 5, 10)
    start = (0, 0)
    goal = (49, 49)  # Or choose any valid goal node in the graph

    # Run the benchmark
    paths = run_benchmark(random_graph, start, goal)
    
    # Print results
    print("\nPaths found (using different heuristics):")
    for i, path in enumerate(paths, 1):
        if path:
            print(f"Path using heuristic h{i}: {path}")
        else:
            print(f"No path found using heuristic h{i}")
